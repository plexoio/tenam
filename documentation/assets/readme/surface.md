# SURFACE PLANE

## Index <a name="index"></a>

1. [Strategy Plane - Reason, Solution and Value](https://github.com/plexoio/tenam/blob/main/documentation/assets/readme/strategy.md)
2. [Scope Plane - Feature and Capability](https://github.com/plexoio/tenam/blob/main/documentation/assets/readme/scope.md)
3. [Structure Plane - Content, Priority and Organization](https://github.com/plexoio/tenam/blob/main/documentation/assets/readme/structure.md)
4. [Skeleton Plane - Layout, Interaction and Relationship](https://github.com/plexoio/tenam/blob/main/documentation/assets/readme/skeleton.md)
5. [Surface Plane - Color, Typography, Effect and Images](https://github.com/plexoio/tenam/blob/main/documentation/assets/readme/surface.md)
6. [Technologies Used](#technologies)
7. [Actual Features Explained](#features)
8. [Future Features Explained](#f-features)
9. [Bugs & Testing Results](#bugs-testing)
10. [Development Process](#development)
11. [Deployment Process](#deployment)
12. [Credits](#credits)

## Surface Plane <a name="surface-plane"></a> | [#](#index)

This time, we didn't need wireframes or extensive discussions about the front-end part since that was provided by 'Code Institute'. We considered the ideas and constraints within the framework they provided.

Initially, we underestimated the importance of following the UX design sequence. However, we were pleasantly surprised by its effectiveness when properly implemented. Hence, we can confidently say that all planes were essential to reach this point (Surface). We understand that it's during the building or coding phase that we may discover any gaps or oversights, albeit in a back-end manner.

We're excited to see how our project takes shape and how we continue to refine it along the way.

### Color

- Default colors provided by 'Code Institute' template.

#### Palette

- Not relevant for this iteration.

### Layout

- The layout of the mockup command-line has been provided as seen before.
- It appears as a rectangular block displayed on the upper right side of the window.
- It presents the program within a black internal window where users interact.
- Everything outside the command-line remains static.

### Fonts

- Initially, Arial was set as the default font, but we changed it to `font-family: 'Newsreader', Arial, serif;`.

### Images

- No additional images were needed.

### Order

- Inside the command line, the menu list follows this order:
    - Assets
    - Transaction
    - Data Analysis
    - Taxation
    - Update Tax Value
    - RSS News
    - Refresh
    - Exit
- The order reflects a progression from simple to complex disclosure.

### Sequences

- Paying attention to `progressive disclosure` allowed us to build a smooth application flow. Users first see the welcome page, then they are directed to log in. Once logged in, they can easily access the various features from the menu.

- The features aim to provide readable content, and users have the option to refresh the window or exit at any time.

For each section and interaction, we considered economy, making the most important elements easily recognizable. We noticed many patterns throughout the product layouts and interactions. It was designed to be readable, with colors provided by the 'Code Institute' template creating good contrasts. We added different fonts when necessary.

We ensured that users cannot get lost on the site, as we made value evident throughout.

**We focused on the following concerns:**

- Repetition
- Contrast
- Proximity
- Alignment
- Accessibility (although not 100% attainable)
- Interaction
- Visual engagement
- Easy learning experience

We aimed to keep things as simple as possible, presenting fewer choices to the users while highlighting concrete features and content to fulfill our mission for this MVP.

After considering these factors, we were able to turn our ideas from the skeleton and surface into code with ease. The coding process was less complicated and more enjoyable, despite different challenges. This approach required less time, energy, and other resources, resulting in less human work, fewer errors, and ultimately, a superior product, even though we are dealing with a backend project.